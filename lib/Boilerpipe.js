// Generated by CoffeeScript 1.9.1
(function() {
  var BaseFilter, BlockProximityFusion, Boilerpipe, BoilerpipeParser, BoilerpipeTextDocument, CanolaFilter, DensityRulesClassifier, DocumentTitleMatchClassifier, ExpandTitleToContentFilter, FilterChain, IgnoreBlocksAfterContentFilter, InvertedFilter, KeepLargestBlockFilter, MarkEverythingContentFilter, MinClauseWordsFilter, MinWordsFilter, NumWordsRulesClassifier, RemoveNonContentBlocksFilter, SimpleBlockFusionProcessor, SplitParagraphBlocksFilter, TerminatingBlocksFinder, TextBlock, htmlparser,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  String.prototype.stripWhitespace = function() {
    return this.replace(/^\s+|\s+$/g, "");
  };

  String.prototype.normalize = function() {
    return this.stripWhitespace().toLowerCase();
  };

  String.prototype.isWord = function() {
    return /[^\W_]/.test(this);
  };

  String.prototype.numberOfWords = function() {
    return this.match(/\w+/g).length;
  };

  String.prototype.isWhitespace = function() {
    return this.length > 0 && /^\W+$/.test(this);
  };

  String.prototype.startsWith = function(match) {
    return this.substring(0, match.length) === match;
  };

  Array.prototype.merge = function(secondArray) {
    return Array.prototype.push.apply(this, secondArray);
  };

  Array.prototype.contains = function(object) {
    return this.indexOf(object) >= 0;
  };

  Array.prototype.where = function(query, matcher) {
    var hit;
    if (matcher == null) {
      matcher = function(a, b) {
        return a === b;
      };
    }
    if (typeof query !== "object") {
      return [];
    }
    hit = Object.keys(query).length;
    return this.filter(function(item) {
      var key, match, val;
      match = 0;
      for (key in query) {
        val = query[key];
        if (matcher(item[key], val)) {
          match += 1;
        }
      }
      return match === hit;
    });
  };

  Array.prototype.removeObject = function(objectToRemove) {
    var indexToRemove;
    if (objectToRemove) {
      indexToRemove = this.indexOf(objectToRemove);
      return this.splice(indexToRemove, 1);
    }
  };

  TextBlock = (function() {
    TextBlock.Title = "Title";

    TextBlock.ArticleMetadata = "ArticleMetadata";

    TextBlock.MightBeContent = "MightBeContent";

    TextBlock.EndOfText = "EndOfText";

    TextBlock.DefaultFullTextWordsThreshold = 9;

    function TextBlock(text, containedTextElements, tagLevel, numWords, numWordsInAnchorText, numWordsInWrappedLines, numWrappedLines, offset) {
      this.text = text != null ? text.replace(/^\s+|\n+$/g, "") : void 0;
      this.containedTextElements = containedTextElements || [];
      this.numWords = numWords || (text != null ? text.split(/\W+/).length : void 0) || 0;
      this.numWordsInAnchorText = numWordsInAnchorText;
      this.numWordsInWrappedLines = numWordsInWrappedLines;
      this.numWrappedLines = numWrappedLines;
      this.offsetStart = offset || 0;
      this.offsetEnd = offset || 0;
      this.tagLevel = tagLevel || 0;
      this.labels = [];
      this.isContent = false;
      this.calculateDensities();
    }

    TextBlock.prototype.description = function() {
      var description;
      description = "TextBlock:\n";
      description += "   offsetStart - offsetEnd = " + this.offsetStart + " - " + this.offsetEnd + "\n";
      description += "   tagLevel = " + this.tagLevel + "\n";
      description += "   numWords = " + this.numWords + "\n";
      description += "   numWordsInAnchorText = " + this.numWordsInAnchorText + "\n";
      description += "   numWrappedLines = " + this.numWrappedLines + "\n";
      description += "   linkDensity = " + this.linkDensity + "\n";
      description += "   isContent = " + (this.isContent ? 'True' : 'False') + "\n";
      description += "'" + this.text + "'";
      return description;
    };

    TextBlock.prototype.calculateDensities = function() {
      if (this.numWordsInWrappedLines === 0) {
        this.numWordsInWrappedLines = this.numWords;
        this.numWrappedLines = 1;
      }
      this.textDensity = this.numWordsInWrappedLines / this.numWrappedLines;
      if (this.numWords === 0) {
        return this.linkDensity = 0.0;
      } else {
        return this.linkDensity = this.numWordsInAnchorText / this.numWords;
      }
    };

    TextBlock.prototype.mergeNext = function(nextTextBlock) {
      this.text += '\n' + nextTextBlock.text;
      this.numWords += nextTextBlock.numWords;
      this.numWordsInAnchorText += nextTextBlock.numWordsInAnchorText;
      this.numWordsInWrappedLines += nextTextBlock.numWordsInWrappedLines;
      this.numWrappedLines += nextTextBlock.numWrappedLines;
      this.offsetStart = Math.min(this.offsetStart, nextTextBlock.offsetStart);
      this.offsetEnd = Math.max(this.offsetEnd, nextTextBlock.offsetEnd);
      this.isContent |= nextTextBlock.isContent;
      this.containedTextElements.merge(nextTextBlock.containedTextElements);
      this.labels.merge(nextTextBlock.labels);
      this.tagLevel = Math.min(this.tagLevel, nextTextBlock.tagLevel);
      return this.calculateDensities();
    };

    TextBlock.prototype.addLabel = function(label) {
      return this.labels.push(label);
    };

    TextBlock.prototype.hasLabel = function(label) {
      return this.labels.contains(label);
    };

    TextBlock.prototype.numFullTextWords = function(minTextDensity) {
      if (minTextDensity == null) {
        minTextDensity = TextBlock.DefaultFullTextWordsThreshold;
      }
      if (this.textDensity >= minTextDensity) {
        return this.numWords;
      } else {
        return 0;
      }
    };

    return TextBlock;

  })();

  BoilerpipeTextDocument = (function() {

    /*
    	Text document encapsulates a title and a series of textBlocks
     */
    function BoilerpipeTextDocument(title, textBlocks) {
      this.title = title;
      this.textBlocks = textBlocks;
    }

    BoilerpipeTextDocument.prototype.content = function() {
      return this.text(true, false);
    };

    BoilerpipeTextDocument.prototype.contentBlocks = function() {
      return this.textBlocks.filter(function(textBlock) {
        return textBlock.isContent;
      });
    };

    BoilerpipeTextDocument.prototype.text = function(includeContent, includeNonContent) {
      var j, len, ref, text, textBlock;
      text = "";
      ref = this.textBlocks;
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        if ((textBlock.isContent && includeContent) || (!textBlock.isContent && includeNonContent)) {
          text += textBlock.text + '\n';
        }
      }
      return text;
    };

    BoilerpipeTextDocument.prototype.numberOfContentBlocks = function() {
      var j, len, numberOfContentBlocks, ref, textBlock;
      numberOfContentBlocks = 0;
      ref = this.textBlocks;
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        if (textBlock.isContent) {
          numberOfContentBlocks++;
        }
      }
      return numberOfContentBlocks;
    };

    BoilerpipeTextDocument.prototype.removeTextBlock = function(textBlock) {
      return this.textBlocks.removeObject(textBlock);
    };

    return BoilerpipeTextDocument;

  })();

  htmlparser = require('htmlparser2');

  BoilerpipeParser = (function() {

    /*
    	Parses the input HTML into an array of TextBlock objects
     */
    BoilerpipeParser.IgnorableElementAction = 'IgnorableElementAction';

    BoilerpipeParser.BodyElementAction = 'BodyElementAction';

    BoilerpipeParser.AnchorTextElementAction = 'AnchorTextElementAction';

    BoilerpipeParser.InlineNoWhitespaceElementAction = 'InlineNoWhitespaceElementAction';

    BoilerpipeParser.InlineWhitespaceElementAction = 'InlineWhitespaceElementAction';

    BoilerpipeParser.EventStartTag = 'EventStartTag';

    BoilerpipeParser.EventEndTag = 'EventEndTag';

    BoilerpipeParser.EventWhitespace = 'EventWhitespace';

    BoilerpipeParser.EventCharacters = 'EventCharacters';

    BoilerpipeParser.AnchorTextStart = 'AnchorTextStart';

    BoilerpipeParser.AnchorTextEnd = 'AnchorTextEnd';

    function BoilerpipeParser(mode) {
      this.parser = new htmlparser.Parser({
        onopentag: (function(_this) {
          return function(elementName, attributes) {
            return _this.startElement(elementName, attributes);
          };
        })(this),
        ontext: (function(_this) {
          return function(text) {
            return _this.foundText(text);
          };
        })(this),
        onclosetag: (function(_this) {
          return function(elementName) {
            return _this.endElement(elementName);
          };
        })(this)
      });
    }

    BoilerpipeParser.prototype.resetToInitialState = function() {
      this.title = '';
      this.textBlocks = [];
      this.offset = 0;
      this.lastStartTag = null;
      this.textBlocks = [];
      this.labelStacks = [];
      this.currentContainedTextElements = [];
      this.tagLevel = 0;
      this.blockTagLevel = null;
      this.ignorableElementDepth = 0;
      this.inBody = 0;
      this.inAnchor = 0;
      this.inAnchorText = false;
      this.clearTextBuffer();
      return this.flush = false;
    };

    BoilerpipeParser.prototype.parseDocumentFromHTML = function(html) {
      this.resetToInitialState();
      this.startParsingDocument();
      this.parser.parseComplete(html);
      this.endParsingDocument();
      return new BoilerpipeTextDocument(this.title, this.textBlocks);
    };

    BoilerpipeParser.prototype.startParsingDocument = function() {};

    BoilerpipeParser.prototype.endParsingDocument = function() {
      return this.flushBlock();
    };

    BoilerpipeParser.prototype.startElement = function(elementName, attributes) {
      this.labelStacks.push([]);
      switch (this.elementTypeForTag(elementName)) {
        case BoilerpipeParser.IgnorableElementAction:
          this.ignorableElementDepth++;
          this.tagLevel++;
          break;
        case BoilerpipeParser.BodyElementAction:
          this.flushBlock();
          this.inBody++;
          this.tagLevel++;
          break;
        case BoilerpipeParser.AnchorTextElementAction:
          this.inAnchor++;
          this.tagLevel++;
          if (this.inAnchor > 1) {
            console.log("Warning: SAX input contains nested A elements -- You have probably hit a bug in your HTML parser (e.g., NekoHTML bug #2909310). Please clean the HTML externally and feed it to boilerpipe again. Trying to recover somehow...");
            endElement(elementName);
          }
          if (this.ignorableElementDepth === 0) {
            this.addToken(BoilerpipeParser.AnchorTextStart);
          }
          break;
        case BoilerpipeParser.InlineWhitespaceElementAction:
        case BoilerpipeParser.InlineNoWhitespaceElementAction:
          break;
        default:
          this.tagLevel++;
          this.flush = true;
      }
      return this.lastStartTag = elementName;
    };

    BoilerpipeParser.prototype.foundText = function(text) {
      var strippedContent, tokens;
      this.textElementIdx++;
      if (this.flush) {
        this.flushBlock();
      }
      if (this.ignorableElementDepth > 0 || (text == null) || text.length === 0) {
        return;
      }
      strippedContent = text.stripWhitespace();
      if (strippedContent.length === 0) {
        return;
      }
      this.textBuffer += text;
      tokens = this.tokenizeString(text);
      if (tokens) {
        this.tokenBuffer.merge(tokens);
      }
      if (this.blockTagLevel == null) {
        this.blockTagLevel = this.tagLevel;
      }
      return this.currentContainedTextElements.push(this.textElementIdx);
    };

    BoilerpipeParser.prototype.endElement = function(elementName) {
      switch (this.elementTypeForTag(elementName)) {
        case BoilerpipeParser.IgnorableElementAction:
          this.ignorableElementDepth--;
          this.tagLevel--;
          this.flush = true;
          break;
        case BoilerpipeParser.BodyElementAction:
          this.flushBlock();
          this.inBody--;
          this.tagLevel--;
          break;
        case BoilerpipeParser.AnchorTextElementAction:
          this.inAnchor--;
          if (this.inAnchor === 0 && this.ignorableElementDepth === 0) {
            this.addToken(BoilerpipeParser.AnchorTextEnd);
          }
          this.tagLevel--;
          break;
        case BoilerpipeParser.InlineWhitespaceElementAction:
        case BoilerpipeParser.InlineNoWhitespaceElementAction:
          break;
        default:
          this.tagLevel--;
          this.flush = true;
      }
      if (this.flush) {
        this.flushBlock();
      }
      this.lastEndTag = elementName;
      return this.labelStacks.pop();
    };

    BoilerpipeParser.prototype.flushBlock = function() {
      var currentLineLength, currentText, j, len, maxLineLength, numTokens, numWords, numWordsCurrentLine, numWordsInAnchorText, numWordsInWrappedLines, numWrappedLines, ref, ref1, textBlock, token;
      this.flush = false;
      if ((this.inBody == null) || this.inBody <= 0) {
        if (((ref = this.lastStartTag) != null ? ref.normalize() : void 0) === "title") {
          this.title || (this.title = this.textBuffer.stripWhitespace());
        }
        this.clearTextBuffer();
        return;
      }
      if (!this.tokenBuffer.length > 0) {
        this.clearTextBuffer();
        return;
      }
      numWords = 0;
      numWordsInAnchorText = 0;
      numWrappedLines = 0;
      currentLineLength = -1;
      maxLineLength = 80;
      numTokens = 0;
      numWordsCurrentLine = 0;
      ref1 = this.tokenBuffer;
      for (j = 0, len = ref1.length; j < len; j++) {
        token = ref1[j];
        if (token === BoilerpipeParser.AnchorTextStart) {
          this.inAnchorText = true;
        } else if (token === BoilerpipeParser.AnchorTextEnd) {
          this.inAnchorText = false;
        } else if (token.isWord()) {
          numTokens++;
          numWords++;
          numWordsCurrentLine++;
          if (this.inAnchorText) {
            numWordsInAnchorText++;
          }
          currentLineLength += token.length + 1;
          if (currentLineLength > maxLineLength) {
            numWrappedLines++;
            currentLineLength = token.length;
            numWordsCurrentLine = 1;
          }
        } else {
          numTokens++;
        }
      }
      if (numTokens > 0) {
        if (numWrappedLines === 0) {
          numWordsInWrappedLines = numWords;
          numWrappedLines = 1;
        } else {
          numWordsInWrappedLines = numWords - numWordsCurrentLine;
        }
        currentText = this.textBuffer;
        textBlock = new TextBlock(currentText, this.currentContainedTextElements, this.blockTagLevel, numWords, numWordsInAnchorText, numWordsInWrappedLines, numWrappedLines, this.offset);
        this.textBlocks.push(textBlock);
        this.offset++;
        this.blockTagLevel = null;
        this.currentContainedTextElements = [];
      }
      return this.clearTextBuffer();
    };

    BoilerpipeParser.prototype.addToken = function(token) {
      if (token != null) {
        return this.tokenBuffer.push(token);
      }
    };

    BoilerpipeParser.prototype.clearTextBuffer = function() {
      this.textBuffer = '';
      return this.tokenBuffer = [];
    };

    BoilerpipeParser.prototype.elementTypeForTag = function(tagName) {
      this.mapOFActionsToTags = {
        "style": BoilerpipeParser.IgnorableElementAction,
        "script": BoilerpipeParser.IgnorableElementAction,
        "option": BoilerpipeParser.IgnorableElementAction,
        "object": BoilerpipeParser.IgnorableElementAction,
        "embed": BoilerpipeParser.IgnorableElementAction,
        "applet": BoilerpipeParser.IgnorableElementAction,
        "a": BoilerpipeParser.AnchorTextElementAction,
        "body": BoilerpipeParser.BodyElementAction,
        "strike": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "u": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "b": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "i": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "em": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "strong": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "span": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "sup": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "code": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "tt": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "sub": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "var": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "abbr": BoilerpipeParser.InlineWhitespaceElementAction,
        "acronym": BoilerpipeParser.InlineWhitespaceElementAction,
        "font": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "noscript": BoilerpipeParser.IgnorableElementAction
      };
      tagName = tagName.toLowerCase();
      return this.mapOFActionsToTags[tagName];
    };

    BoilerpipeParser.prototype.tokenizeString = function(input) {
      return input.match(/\ue00a?[\w\"'\.,\!\@\-\:\;\$\?\(\)\/]+/g);
    };

    return BoilerpipeParser;

  })();


  /*
  	
  	Filters
  	=======
  	
  	Simple Filters:
  	---------------
  		MarkEverythingContentFilter - Marks all blocks as content.
  		InvertedFilter - Reverts the "isContent" flag for all TextBlocks
  		RemoveNonContentBlocksFilter - Removes TextBlocks which have explicitly been marked as "not content". 
  		MinWordsFilter - Keeps only those content blocks which contain at least k words.
  		MinClauseWordsFilter - Keeps only blocks that have at least one segment fragment ("clause") with at least k words
  		SplitParagraphBlocksFilter - Splits TextBlocks at paragraph boundaries
  		SurroundingToContentFilter
  		LabelToBoilerplateFilter - Marks all blocks that contain a given label as "boilerplate".
  		LabelToContentFilter - Marks all blocks that contain a given label as "content".
  	
  	Heuristic Filters:
  	------------------
  		SimpleBlockFusionProcessor - Merges two subsequent blocks if their text densities are equal.
  		ContentFusion
  		LabelFusion - Fuses adjacent blocks if their labels are equal.
  		BlockProximityFusion - Fuses adjacent blocks if their distance (in blocks) does not exceed a certain limit.
  		KeepLargestBlockFilter - Keeps the largest {@link TextBlock} only (by the number of words)
  		ExpandTitleToContentFilter - Marks all TextBlocks "content" which are between the headline and the part that has already been marked content, if they are marked MIGHT_BE_CONTENT
  		ArticleMetadataFilter
  		AddPrecedingLabelsFilter - Adds the labels of the preceding block to the current block, optionally adding a prefix.
  		DocumentTitleMatchClassifier - Marks TextBlocks which contain parts of the HTML TITLE tag
  	
  	English-trained Heuristic Filters:
  	----------------------------------
  		MinFulltextWordsFilter - Keeps only those content blocks which contain at least k full-text words
  		KeepLargestFulltextBlockFilter - Keeps the largest TextBlock only (by the number of words)
  		IgnoreBlocksAfterContentFilter - Marks all blocks as "non-content" that occur after blocks that have been marked INDICATES_END_OF_TEXT
  		IgnoreBlocksAfterContentFromEndFilter - like above
  		TerminatingBlocksFinder - Finds blocks which are potentially indicating the end of an article text and marks them with INDICATES_END_OF_TEXT
  		NumWordsRulesClassifier - Classifies TextBlocks as content/not-content through rules that have been determined using the C4.8 machine learning algorithm
  		DensityRulesClassifier - lassifies TextBlocks as content/not-content through rules that have been determined using the C4.8 machine learning algorithm
  		CanolaFilter - A full-text extractor trained on krdwrd Canola
   */

  BaseFilter = (function() {
    function BaseFilter() {}

    BaseFilter.prototype.process = function(document) {
      return false;
    };

    return BaseFilter;

  })();

  FilterChain = (function(superClass) {
    extend(FilterChain, superClass);

    function FilterChain(filters) {
      this.filters = filters;
    }

    FilterChain.prototype.process = function(document) {
      var filter, foundChanges, j, len, ref;
      foundChanges = false;
      ref = this.filters;
      for (j = 0, len = ref.length; j < len; j++) {
        filter = ref[j];
        foundChanges = filter.process(document);
      }
      return foundChanges;
    };

    return FilterChain;

  })(BaseFilter);

  MarkEverythingContentFilter = (function(superClass) {
    extend(MarkEverythingContentFilter, superClass);

    function MarkEverythingContentFilter() {
      return MarkEverythingContentFilter.__super__.constructor.apply(this, arguments);
    }

    MarkEverythingContentFilter.prototype.process = function(document) {
      var j, len, ref, results, textBlock;
      ref = document.textBlocks;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        results.push(textBlock.isContent = true);
      }
      return results;
    };

    return MarkEverythingContentFilter;

  })(BaseFilter);

  InvertedFilter = (function(superClass) {
    extend(InvertedFilter, superClass);

    function InvertedFilter() {
      return InvertedFilter.__super__.constructor.apply(this, arguments);
    }

    InvertedFilter.prototype.process = function(document) {
      var j, len, textBlock, textBlocks;
      textBlocks = document.textBlocks;
      if (textBlocks.length === 0) {
        return false;
      }
      for (j = 0, len = textBlocks.length; j < len; j++) {
        textBlock = textBlocks[j];
        textBlock.isContent = !textBlock.isContent;
      }
      return true;
    };

    return InvertedFilter;

  })(BaseFilter);

  RemoveNonContentBlocksFilter = (function(superClass) {
    extend(RemoveNonContentBlocksFilter, superClass);

    function RemoveNonContentBlocksFilter() {
      return RemoveNonContentBlocksFilter.__super__.constructor.apply(this, arguments);
    }

    RemoveNonContentBlocksFilter.prototype.process = function(document) {
      var foundChanges, j, len, ref, textBlock;
      foundChanges = false;
      ref = document.textBlocks;
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        if (!(textBlock != null ? textBlock.isContent : void 0)) {
          document.removeTextBlock(textBlock);
          foundChanges = true;
        }
      }
      return foundChanges;
    };

    return RemoveNonContentBlocksFilter;

  })(BaseFilter);

  MinWordsFilter = (function(superClass) {
    extend(MinWordsFilter, superClass);

    function MinWordsFilter(minWords) {
      this.minWords = minWords;
    }

    MinWordsFilter.prototype.process = function(document) {
      var foundChanges, j, len, ref, textBlock;
      foundChanges = false;
      ref = document.textBlocks;
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        if (textBlock.isContent && tb.getNumWords() < self.minWords) {
          textBlock.isContent = false;
          foundChanges = true;
        }
      }
      return foundChanges;
    };

    return MinWordsFilter;

  })(BaseFilter);

  MinClauseWordsFilter = (function(superClass) {
    extend(MinClauseWordsFilter, superClass);

    function MinClauseWordsFilter(minWords, acceptClausesWithoutDelimiter) {
      if (minWords == null) {
        minWords = 5;
      }
      if (acceptClausesWithoutDelimiter == null) {
        acceptClausesWithoutDelimiter = false;
      }
      this.process = bind(this.process, this);
      this.minWords = minWords;
      this.acceptClausesWithoutDelimiter = acceptClausesWithoutDelimiter;
    }

    MinClauseWordsFilter.prototype.process = function(document) {
      var currentIndex, foundChanges, hasClause, j, k, len, len1, numberOfClauses, possibleClause, possibleClauses, ref, text, textBlock;
      foundChanges = false;
      ref = document.textBlocks;
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        if (textBlock.isContent) {
          hasClause = false;
          text = textBlock.text + ' ';
          possibleClauses = text.split(/\b[\,\.\:\;\!\?]+(?:\s+|\Z)/);
          numberOfClauses = possibleClauses.length;
          for (currentIndex = k = 0, len1 = possibleClauses.length; k < len1; currentIndex = ++k) {
            possibleClause = possibleClauses[currentIndex];
            if (currentIndex < numberOfClauses - 1 || this.acceptClausesWithoutDelimiter) {
              hasClause = this.isClauseAccepted(possibleClause);
              if (hasClause) {
                break;
              }
            }
          }
          if (!hasClause) {
            textBlock.isContent = false;
            foundChanges = true;
          }
        }
      }
      return foundChanges;
    };

    MinClauseWordsFilter.prototype.isClauseAccepted = function(text) {
      var words;
      words = text.split(/\s+/);
      return words && words.length >= this.minWords;
    };

    return MinClauseWordsFilter;

  })(BaseFilter);

  SplitParagraphBlocksFilter = (function(superClass) {
    extend(SplitParagraphBlocksFilter, superClass);

    function SplitParagraphBlocksFilter() {
      return SplitParagraphBlocksFilter.__super__.constructor.apply(this, arguments);
    }

    SplitParagraphBlocksFilter.prototype.process = function(document) {
      var foundChanges, isContent, j, k, labels, len, len1, newBlocks, newTextBlock, paragraph, paragraphs, textBlock, textBlocks;
      foundChanges = false;
      textBlocks = document.textBlocks;
      newBlocks = [];
      for (j = 0, len = textBlocks.length; j < len; j++) {
        textBlock = textBlocks[j];
        paragraphs = textBlock.text.split(/[\n\r]+/);
        if (paragraphs.length < 2) {
          newBlocks.push(textBlock);
        } else {
          isContent = textBlock.isContent;
          labels = textBlock.labels;
          for (k = 0, len1 = paragraphs.length; k < len1; k++) {
            paragraph = paragraphs[k];
            newTextBlock = new TextBlock(paragraph);
            newTextBlock.isContent = isContent;
            newTextBlock.labels = labels;
            newBlocks.push(newTextBlock);
          }
          foundChanges = true;
        }
      }
      if (foundChanges) {
        document.textBlocks = newBlocks;
      }
      return foundChanges;
    };

    return SplitParagraphBlocksFilter;

  })(BaseFilter);


  /*
  Heuristic Filters:
   */

  SimpleBlockFusionProcessor = (function(superClass) {
    extend(SimpleBlockFusionProcessor, superClass);

    function SimpleBlockFusionProcessor() {
      return SimpleBlockFusionProcessor.__super__.constructor.apply(this, arguments);
    }

    SimpleBlockFusionProcessor.prototype.process = function(document) {
      var count, currentTextBlock, foundChanges, j, len, previousTextBlock, ref, textBlocks;
      textBlocks = document.textBlocks;
      if (textBlocks.length < 2) {
        return false;
      }
      foundChanges = false;
      previousTextBlock = textBlocks[0];
      count = 0;
      ref = textBlocks.slice(1);
      for (j = 0, len = ref.length; j < len; j++) {
        currentTextBlock = ref[j];
        if ((previousTextBlock != null) && previousTextBlock.textDensity === currentTextBlock.textDensity) {
          previousTextBlock.mergeNext(currentTextBlock);
          document.removeTextBlock(currentTextBlock);
          foundChanges = true;
        } else {
          previousTextBlock = currentTextBlock;
        }
      }
      return foundChanges;
    };

    return SimpleBlockFusionProcessor;

  })(BaseFilter);

  BlockProximityFusion = (function(superClass) {
    extend(BlockProximityFusion, superClass);

    function BlockProximityFusion(maxBlocksDistance, contentOnly, sameTagLevelOnly) {
      if (maxBlocksDistance == null) {
        maxBlocksDistance = 1;
      }
      if (contentOnly == null) {
        contentOnly = false;
      }
      if (sameTagLevelOnly == null) {
        sameTagLevelOnly = false;
      }
      this.maxBlocksDistance = maxBlocksDistance;
      this.contentOnly = contentOnly;
      this.sameTagLevelOnly = sameTagLevelOnly;
    }

    BlockProximityFusion.prototype.process = function(document) {
      var blockIndex, diffBlocks, hasFoundChanges, j, k, len, len1, ok, previousBlock, ref, startIndex, textBlock, textBlocks;
      textBlocks = document.textBlocks;
      if (textBlocks.length < 2) {
        return false;
      }
      startIndex = null;
      if (this.contentOnly) {
        for (blockIndex = j = 0, len = textBlocks.length; j < len; blockIndex = ++j) {
          textBlock = textBlocks[blockIndex];
          if (textBlock.isContent) {
            startIndex = blockIndex;
            break;
          }
        }
        if (!startIndex) {
          return false;
        }
      } else {
        startIndex = 0;
      }
      previousBlock = textBlocks[startIndex];
      hasFoundChanges = false;
      ref = textBlocks.slice(startIndex + 1);
      for (k = 0, len1 = ref.length; k < len1; k++) {
        textBlock = ref[k];
        if (!textBlock.isContent) {
          previousBlock = textBlock;
        } else {
          diffBlocks = textBlock.offsetStart - previousBlock.offsetEnd - 1;
          ok = false;
          if (diffBlocks <= this.maxBlocksDistance) {
            if (!(this.contentOnly && !previousBlock.isContent || !textBlock.isContent) || !(this.sameTagLevelOnly && previousBlock.tagLevel !== textBlock.tagLevel)) {
              ok = true;
            }
          }
          if (ok) {
            previousBlock.mergeNext(textBlock);
            document.removeTextBlock(textBlock);
            hasFoundChanges = true;
          } else {
            previousBlock = textBlock;
          }
        }
      }
      return hasFoundChanges;
    };

    return BlockProximityFusion;

  })(BaseFilter);

  KeepLargestBlockFilter = (function(superClass) {
    extend(KeepLargestBlockFilter, superClass);

    function KeepLargestBlockFilter(expandToSameLevelText) {
      if (expandToSameLevelText == null) {
        expandToSameLevelText = false;
      }
      this.expandToSameLevelText = expandToSameLevelText;
    }

    KeepLargestBlockFilter.prototype.process = function(document) {
      var contentBlocks, j, k, l, largestBlock, largestBlockIndex, len, len1, len2, ref, ref1, tagLevel, tagLevelOfLargestBlock, textBlock, textBlocks;
      textBlocks = document.textBlocks;
      if (textBlocks.length < 2) {
        return false;
      }
      contentBlocks = textBlocks.filter(function(textBlock) {
        return textBlock.isContent;
      });
      largestBlock = contentBlocks.reduce(function(a, b) {
        if (a.numWords > b.numWords) {
          return a;
        } else {
          return b;
        }
      });
      if (largestBlock != null) {
        largestBlock.isContent = true;
      }
      for (j = 0, len = textBlocks.length; j < len; j++) {
        textBlock = textBlocks[j];
        if (textBlock !== largestBlock) {
          textBlock.isContent = false;
          textBlock.addLabel(TextBlock.MightBeContent);
        }
      }
      if (this.expandToSameLevelText && (largestBlock != null)) {
        tagLevelOfLargestBlock = largestBlock.tagLevel;
        largestBlockIndex = textBlocks.indexOf(largestBlock);
        ref = textBlocks.slice(largestBlockIndex);
        for (k = 0, len1 = ref.length; k < len1; k++) {
          textBlock = ref[k];
          tagLevel = textBlock.tagLevel;
          if (tagLevel < tagLevelOfLargestBlock) {
            break;
          }
          if (tagLevel === tagLevelOfLargestBlock) {
            textBlock.isContent = true;
          }
        }
        ref1 = textBlocks.slice(0, +largestBlockIndex + 1 || 9e9);
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          textBlock = ref1[l];
          tagLevel = textBlock.tagLevel;
          if (tagLevel < tagLevelOfLargestBlock) {
            break;
          }
          if (tagLevel === tagLevelOfLargestBlock) {
            textBlock.isContent = true;
          }
        }
      }
      return true;
    };

    return KeepLargestBlockFilter;

  })(BaseFilter);

  ExpandTitleToContentFilter = (function(superClass) {
    extend(ExpandTitleToContentFilter, superClass);

    function ExpandTitleToContentFilter() {
      return ExpandTitleToContentFilter.__super__.constructor.apply(this, arguments);
    }

    ExpandTitleToContentFilter.prototype.process = function(document) {
      var contentStart, currentIndex, foundChanges, j, k, len, len1, ref, ref1, textBlock, titleIndex;
      titleIndex = null;
      contentStart = null;
      ref = document.textBlocks;
      for (currentIndex = j = 0, len = ref.length; j < len; currentIndex = ++j) {
        textBlock = ref[currentIndex];
        if (contentStart === null && textBlock.hasLabel(TextBlock.Title)) {
          titleIndex = currentIndex;
        }
        if (contentStart === null && textBlock.isContent) {
          contentStart = currentIndex;
        }
      }
      foundChanges = false;
      if (contentStart <= titleIndex || titleIndex === null) {
        return false;
      }
      ref1 = document.textBlocks.slice(titleIndex, +contentStart + 1 || 9e9);
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        textBlock = ref1[k];
        if (textBlock.hasLabel(TextBlock.MightBeContent)) {
          textBlock.isContent = true;
          foundChanges = true;
        }
      }
      return foundChanges;
    };

    return ExpandTitleToContentFilter;

  })(BaseFilter);

  DocumentTitleMatchClassifier = (function(superClass) {
    extend(DocumentTitleMatchClassifier, superClass);

    function DocumentTitleMatchClassifier(title, useDocumentTitle) {
      if (useDocumentTitle == null) {
        useDocumentTitle = false;
      }
      this.useDocumentTitle = useDocumentTitle;
      if (useDocumentTitle) {
        this.potentialTitles = [];
      } else {
        this.potentialTitles = this.findPotentialTitles("title");
      }
    }

    DocumentTitleMatchClassifier.prototype.process = function(document) {
      var j, k, len, len1, potentialTitle, potentialTitles, ref, text, textBlock;
      if (this.useDocumentTitle) {
        potentialTitles = this.findPotentialTitles(document.title);
      }
      if (!potentialTitles || potentialTitles.length === 0) {
        return false;
      }
      ref = document.textBlocks;
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        text = textBlock.text.normalize();
        for (k = 0, len1 = potentialTitles.length; k < len1; k++) {
          potentialTitle = potentialTitles[k];
          if (potentialTitle.normalize() === text) {
            textBlock.addLabel(TextBlock.Title);
            return true;
          }
        }
      }
      return false;
    };

    DocumentTitleMatchClassifier.prototype.findPotentialTitles = function(title) {
      var j, len, match, pattern, patterns, potentialTitles;
      title = title != null ? title.stripWhitespace() : void 0;
      if ((title == null) || title.length === 0) {
        return null;
      }
      potentialTitles = [];
      potentialTitles.push(title);
      patterns = [/[ ]*[\||:][ ]*/, /[ ]*[\||:\(\)][ ]*/, /[ ]*[\||:\(\)\-][ ]*/, /[ ]*[\||,|:\(\)\-][ ]*/];
      for (j = 0, len = patterns.length; j < len; j++) {
        pattern = patterns[j];
        match = this.longestMatch(title, pattern);
        if (match) {
          potentialTitles.push(match);
        }
      }
      return potentialTitles;
    };

    DocumentTitleMatchClassifier.prototype.longestMatch = function(title, pattern) {
      var j, len, longestNumberOfWords, longestSection, numberOfWordsInSection, section, sections;
      sections = title.split(pattern);
      if (sections.length === 0) {
        return null;
      }
      longestNumberOfWords = 0;
      longestSection = "";
      for (j = 0, len = sections.length; j < len; j++) {
        section = sections[j];
        if (section.search(".com" === -1)) {
          numberOfWordsInSection = section.numberOfWords();
          if (numberOfWordsInSection > longestNumberOfWords || section.length > longestSection.length) {
            longestNumberOfWords = numberOfWordsInSection;
            longestSection = section;
          }
        }
      }
      if (longestSection.length === 0) {
        return false;
      } else {
        return longestSection.normalize();
      }
    };

    return DocumentTitleMatchClassifier;

  })(BaseFilter);

  IgnoreBlocksAfterContentFilter = (function(superClass) {
    extend(IgnoreBlocksAfterContentFilter, superClass);

    function IgnoreBlocksAfterContentFilter(minimumNumberOfWords) {
      if (minimumNumberOfWords == null) {
        minimumNumberOfWords = 60;
      }
      this.minimumNumberOfWords = minimumNumberOfWords;
    }

    IgnoreBlocksAfterContentFilter.prototype.process = function(document) {
      var foundChanges, foundEndOfText, j, len, numWords, ref, textBlock;
      numWords = 0;
      foundEndOfText = false;
      foundChanges = false;
      ref = document.textBlocks;
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        if (textBlock.isContent) {
          numWords += textBlock.numFullTextWords();
        }
        if (textBlock.hasLabel(TextBlock.EndOfText) && numWords >= this.minimumNumberOfWords) {
          foundEndOfText = true;
        }
        if (foundEndOfText) {
          textBlock.isContent = false;
          foundChanges = true;
        }
      }
      return foundChanges;
    };

    return IgnoreBlocksAfterContentFilter;

  })(BaseFilter);

  TerminatingBlocksFinder = (function(superClass) {
    extend(TerminatingBlocksFinder, superClass);

    function TerminatingBlocksFinder() {
      return TerminatingBlocksFinder.__super__.constructor.apply(this, arguments);
    }

    TerminatingBlocksFinder.prototype.process = function(document) {
      var equalMatch, foundChanges, foundMatch, inMatches, j, len, lowercaseText, numbersMatch, ref, ref1, startMatches, text, textBlock;
      foundChanges = false;
      ref = document.textBlocks;
      for (j = 0, len = ref.length; j < len; j++) {
        textBlock = ref[j];
        if (textBlock.numWords >= 15) {
          continue;
        }
        text = (ref1 = textBlock.text) != null ? ref1.stripWhitespace() : void 0;
        if (text.length < 8) {
          continue;
        }
        lowercaseText = text.toLowerCase();
        startMatches = [" reuters", "please rate this", "post a comment"];
        inMatches = ["what you think...", "add your comment", "add comment", "reader views", "have your say", "reader comments", "rtta artikeln"];
        equalMatch = ["thanks for your comments - this feedback is now closed"];
        numbersMatch = [" comments", " users responded in"];
        foundMatch = false;
        foundMatch |= indexOf.call(equalMatch != null, lowercaseText) >= 0;
        foundMatch |= lowercaseText.startsWith("comments");
        foundMatch |= !startMatches.every(function(match) {
          return !lowercaseText.startsWith(match);
        });
        foundMatch |= !inMatches.every(function(match) {
          return !~lowercaseText.indexOf(match);
        });
        foundMatch |= !equalMatch.every(function(match) {
          return lowercaseText !== match;
        });
        foundMatch |= this.isNumberFollowedByString(lowercaseText, numbersMatch);
        if (foundMatch) {
          textBlock.addLabel(TextBlock.EndOfText);
          foundChanges = true;
        }
      }
      return foundChanges;
    };

    TerminatingBlocksFinder.prototype.isNumberFollowedByString = function(text, possibleMatches) {
      var j, len, matchEnd, matchResult, possibleMatch;
      matchResult = /^\W*\d+/.exec(text);
      if (matchResult) {
        matchEnd = matchResult['index'] + matchResult[0].length;
        for (j = 0, len = possibleMatches.length; j < len; j++) {
          possibleMatch = possibleMatches[j];
          if (text.slice(matchEnd).startsWith(possibleMatch)) {
            return true;
          }
        }
      }
      return false;
    };

    return TerminatingBlocksFinder;

  })(BaseFilter);

  NumWordsRulesClassifier = (function(superClass) {
    extend(NumWordsRulesClassifier, superClass);

    function NumWordsRulesClassifier() {
      return NumWordsRulesClassifier.__super__.constructor.apply(this, arguments);
    }

    NumWordsRulesClassifier.prototype.process = function(document) {
      var currentBlock, foundChanges, i, isContent, j, len, nextBlock, numberOfTextBlocks, previousBlock, textBlocks;
      textBlocks = document.textBlocks;
      foundChanges = false;
      numberOfTextBlocks = textBlocks.length;
      for (i = j = 0, len = textBlocks.length; j < len; i = ++j) {
        currentBlock = textBlocks[i];
        previousBlock = i > 0 ? textBlocks[i - 1] : this.newPlaceholderTextBlock;
        nextBlock = (i + 1) < numberOfTextBlocks ? textBlocks[i + 1] : this.newPlaceholderTextBlock;
        isContent = true;
        if (currentBlock.linkDensity > 0.333333) {
          isContent = false;
        } else if (previousBlock.linkDensity <= 0.555556) {
          if (currentBlock.numWords <= 16 && nextBlock.numWords <= 15 && previousBlock.numWords <= 4) {
            isContent = false;
          }
        } else if (currentBlock.numWords <= 40 && nextBlock.numWords <= 17) {
          isContent = false;
        }
        if (!foundChanges) {
          foundChanges = currentBlock.isContent !== isContent;
        }
        currentBlock.isContent = isContent;
      }
      return foundChanges;
    };

    NumWordsRulesClassifier.prototype.newPlaceholderTextBlock = function() {
      return new TextBlock(null, null, null, null, null, null, null, -1);
    };

    return NumWordsRulesClassifier;

  })(BaseFilter);

  DensityRulesClassifier = (function(superClass) {
    extend(DensityRulesClassifier, superClass);

    function DensityRulesClassifier() {
      return DensityRulesClassifier.__super__.constructor.apply(this, arguments);
    }

    DensityRulesClassifier.prototype.process = function(document) {
      var currentBlock, foundChanges, i, isContent, j, len, nextBlock, numberOfTextBlocks, previousBlock, textBlocks;
      textBlocks = document.textBlocks;
      foundChanges = false;
      numberOfTextBlocks = textBlocks.length;
      for (i = j = 0, len = textBlocks.length; j < len; i = ++j) {
        currentBlock = textBlocks[i];
        previousBlock = i > 0 ? textBlocks[i - 1] : this.newPlaceholderTextBlock;
        nextBlock = (i + 1) < numberOfTextBlocks ? textBlocks[i + 1] : this.newPlaceholderTextBlock;
        isContent = false;
        if (currentBlock.linkDensity <= 0.333333) {
          if (previousBlock.linkDensity <= 0.555556) {
            if (currentBlock.textDensity <= 9) {
              if (nextBlock.textDensity <= 10) {
                if (previousBlock.textDensity > 4) {
                  isContent = true;
                }
              } else {
                isContent = true;
              }
            } else if (nextBlock.textDensity !== 0) {
              isContent = true;
            }
          } else if (nextBlock.textDensity > 11) {
            isContent = true;
          }
        }
        if (!foundChanges) {
          foundChanges = currentBlock.isContent !== isContent;
        }
        currentBlock.isContent = isContent;
      }
      return foundChanges;
    };

    DensityRulesClassifier.prototype.newPlaceholderTextBlock = function() {
      return new TextBlock(null, null, null, null, null, null, null, -1);
    };

    return DensityRulesClassifier;

  })(BaseFilter);

  CanolaFilter = (function(superClass) {
    extend(CanolaFilter, superClass);

    function CanolaFilter() {
      return CanolaFilter.__super__.constructor.apply(this, arguments);
    }

    CanolaFilter.prototype.process = function(document) {
      var hasChanges, textBlocks;
      textBlocks = document.textBlocks;
      return hasChanges = False;
    };

    return CanolaFilter;

  })(BaseFilter);

  Boilerpipe = (function() {
    function Boilerpipe() {}

    Boilerpipe.DefaultExtractor = "DefaultExtractor";

    Boilerpipe.ArticleExtractor = "ArticleExtractor";

    Boilerpipe.KeepEverythingExtractor = "KeepEverythingExtractor";

    Boilerpipe.LargestContentExtractor = "LargestContentExtractor";

    Boilerpipe.CanolaExtractor = "CanolaExtractor";

    Boilerpipe.Unfiltered = "Unfiltered";

    Boilerpipe.documentFromHTML = function(html, filterType) {
      var document, filterChain, foundChanges, parser;
      parser = new BoilerpipeParser;
      document = parser.parseDocumentFromHTML(html);
      filterChain = this.filterChainForType(filterType);
      foundChanges = filterChain != null ? filterChain.process(document) : void 0;
      return document;
    };

    Boilerpipe.filterChainForType = function(filterType) {
      switch (filterType) {
        case Boilerpipe.ArticleExtractor:

          /*
          				A full-text extractor which is tuned towards news articles.
          				In this scenario it achieves higher accuracy than DefaultExtractor.
          				Works very well for most types of Article-like HTML.
           */
          return new FilterChain([new TerminatingBlocksFinder(), new DocumentTitleMatchClassifier(null, false), new NumWordsRulesClassifier(), new IgnoreBlocksAfterContentFilter(), new BlockProximityFusion(1, false, false), new RemoveNonContentBlocksFilter(), new BlockProximityFusion(1, true, false), new KeepLargestBlockFilter(), new ExpandTitleToContentFilter()]);
        case Boilerpipe.LargestContentExtractor:

          /*
          				A full-text extractor which extracts the largest text component of a page.
          				For news articles, it may perform better than the {@link DefaultExtractor},
          				but usually worse than {@link ArticleExtractor}.
           */
          return new FilterChain([new NumWordsRulesClassifier(), new BlockProximityFusion(1, false, false), new KeepLargestBlockFilter()]);
        case Boilerpipe.CanolaExtractor:

          /*
          				Trained on krdwrd Canola (different definition of "boilerplate").
          				You may give it a try.
           */
          return new FilterChain([new CanolaFilter()]);
        case Boilerpipe.KeepEverythingExtractor:

          /*
          				Only really usefull for testing the parser
           */
          return new FilterChain([new MarkEverythingContentFilter()]);
        case Boilerpipe.Unfiltered:

          /*
          				Do nothing
           */
          break;
        default:

          /*
          				Boilerpipe.DefaultExtractor
          				Usually worse than ArticleExtractor, but simpler/no heuristics
          				A quite generic full-text extractor
           */
          return new FilterChain([new SimpleBlockFusionProcessor(), new BlockProximityFusion(1, false, false), new DensityRulesClassifier()]);
      }
    };

    return Boilerpipe;

  })();

  module.exports = Boilerpipe;

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var BaseFilter, BlockProximityFusion, Boilerpipe, BoilerpipeParser, DocumentTitleMatchClassifier, FilterChain, MarkEverythingContentFilter, NumWordsRulesClassifier, SimpleBlockFusionProcessor, TerminatingBlocksFinder, TextBlock, TextDocument, fs, getContentFromFile, getContentFromHTML, htmlparser, _ref, _ref1, _ref2, _ref3,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  String.prototype.stripWhitespace = function() {
    return this.replace(/^\s+|\s+$/g, "");
  };

  String.prototype.normalize = function() {
    return this.stripWhitespace().toLowerCase();
  };

  String.prototype.isWord = function() {
    return /[^\W_]/.test(this);
  };

  String.prototype.numberOfWords = function() {
    return this.match(/\w+/g).length;
  };

  String.prototype.isWhitespace = function() {
    return this.length > 0 && /^\W+$/.test(this);
  };

  String.prototype.startsWith = function(match) {
    if (match != null) {
      return this.substring(0, match.length) === match;
    }
  };

  Array.prototype.merge = function(secondArray) {
    return Array.prototype.push.apply(this, secondArray);
  };

  Array.prototype.where = function(query, matcher) {
    var hit;
    if (matcher == null) {
      matcher = function(a, b) {
        return a === b;
      };
    }
    if (typeof query !== "object") {
      return [];
    }
    hit = Object.keys(query).length;
    return this.filter(function(item) {
      var key, match, val;
      match = 0;
      for (key in query) {
        val = query[key];
        if (matcher(item[key], val)) {
          match += 1;
        }
      }
      return match === hit;
    });
  };

  Array.prototype.removeObject = function(objectToRemove) {
    var indexToRemove;
    if (objectToRemove) {
      indexToRemove = this.indexOf(objectToRemove);
      return this.splice(indexToRemove, 1);
    }
  };

  TextBlock = (function() {
    TextBlock.EndOfText = "EndOfText";

    function TextBlock(text, currentContainedTextElements, tagLevel, numWords, numWordsInAnchorText, numWordsInWrappedLines, numWrappedLines, offsetBlocks) {
      this.text = text != null ? text.replace(/^\s+|\n+$/g, "") : void 0;
      this.currentContainedTextElements = currentContainedTextElements;
      this.numWords = numWords;
      this.numWordsInAnchorText = numWordsInAnchorText;
      this.numWordsInWrappedLines = numWordsInWrappedLines;
      this.numWrappedLines = numWrappedLines;
      this.offsetBlocksStart = offsetBlocks;
      this.offsetBlocksEnd = offsetBlocks;
      this.tagLevel = tagLevel;
      this.isContent = true;
      this.labels = [];
      this.calculateDensities();
    }

    TextBlock.prototype.description = function() {
      var description;
      description = "TextBlock:\n";
      description += "   offsetBlocksStart - offsetBlocksEnd = " + this.offsetBlocksStart + " - " + this.offsetBlocksEnd + "\n";
      description += "   tagLevel = " + this.tagLevel + "\n";
      description += "   numWords = " + this.numWords + "\n";
      description += "   numWordsInAnchorText = " + this.numWordsInAnchorText + "\n";
      description += "   numWrappedLines = " + this.numWrappedLines + "\n";
      description += "   linkDensity = " + this.linkDensity + "\n";
      description += "'" + this.text + "'";
      return description;
    };

    TextBlock.prototype.calculateDensities = function() {
      if (this.numWordsInWrappedLines === 0) {
        this.numWordsInWrappedLines = this.numWords;
        this.numWrappedLines = 1;
      }
      this.textDensity = this.numWordsInWrappedLines / this.numWrappedLines;
      if (this.numWords === 0) {
        return this.linkDensity = 0.0;
      } else {
        return this.linkDensity = this.numWordsInAnchorText / this.numWords;
      }
    };

    TextBlock.prototype.mergeNext = function(nextTextBlock) {
      if (typeof text === "undefined" || text === null) {
        this.text = "";
      }
      this.text += '\n' + nextTextBlock.text;
      this.numWords += nextTextBlock.numWords;
      this.numWordsInAnchorText += nextTextBlock.numWordsInAnchorText;
      this.numWordsInWrappedLines += nextTextBlock.numWordsInWrappedLines;
      this.numWrappedLines += nextTextBlock.numWrappedLines;
      this.offsetBlocksStart = Math.min(this.offsetBlocksStart, nextTextBlock.offsetBlocksStart);
      this.offsetBlocksEnd = Math.max(this.offsetBlocksEnd, nextTextBlock.offsetBlocksEnd);
      this.calculateDensities();
      this.isContent |= nextTextBlock.isContent;
      this.containedTextElements |= nextTextBlock.containedTextElements;
      this.numFullTextWords += this.numFullTextWords;
      this.labels |= nextTextBlock.labels;
      return this.tagLevel = Math.min(this.tagLevel, nextTextBlock.tagLevel);
    };

    TextBlock.prototype.addLabel = function(label) {
      if (label != null) {
        return this.labels.push(label);
      }
    };

    return TextBlock;

  })();

  TextDocument = (function() {
    /*
    	Text document encapsulates a title and a series of textBlocks
    */

    function TextDocument(title, textBlocks) {
      this.title = title;
      this.textBlocks = textBlocks;
    }

    TextDocument.prototype.content = function() {
      return this.text(true, false);
    };

    TextDocument.prototype.text = function(includeContent, includeNonContent) {
      var text, textBlock, _i, _len, _ref;
      text = "";
      _ref = this.textBlocks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        textBlock = _ref[_i];
        if ((textBlock.isContent && includeContent) || (!textBlock.isContent && includeNonContent)) {
          text += textBlock.text + '\n';
        }
      }
      return text;
    };

    TextDocument.prototype.removeTextBlock = function(textBlock) {
      return this.textBlocks.removeObject(textBlock);
    };

    return TextDocument;

  })();

  htmlparser = require('htmlparser2');

  BoilerpipeParser = (function() {
    /*
    	Parses the input HTML into an array of TextBlock objects
    */

    BoilerpipeParser.IgnorableElementAction = 'IgnorableElementAction';

    BoilerpipeParser.BodyElementAction = 'BodyElementAction';

    BoilerpipeParser.AnchorTextElementAction = 'AnchorTextElementAction';

    BoilerpipeParser.InlineNoWhitespaceElementAction = 'InlineNoWhitespaceElementAction';

    BoilerpipeParser.InlineWhitespaceElementAction = 'InlineWhitespaceElementAction';

    BoilerpipeParser.EventStartTag = 'EventStartTag';

    BoilerpipeParser.EventEndTag = 'EventEndTag';

    BoilerpipeParser.EventWhitespace = 'EventWhitespace';

    BoilerpipeParser.EventCharacters = 'EventCharacters';

    BoilerpipeParser.AnchorTextStart = 'AnchorTextStart';

    BoilerpipeParser.AnchorTextEnd = 'AnchorTextEnd';

    function BoilerpipeParser(mode) {
      var _this = this;
      this.parser = new htmlparser.Parser({
        onopentag: function(elementName, attributes) {
          return _this.startElement(elementName, attributes);
        },
        ontext: function(text) {
          return _this.foundText(text);
        },
        onclosetag: function(elementName) {
          return _this.endElement(elementName);
        }
      });
    }

    BoilerpipeParser.prototype.resetToInitialState = function() {
      this.title = '';
      this.textBlocks = [];
      this.offsetBlocks = 0;
      this.lastStartTag = null;
      this.textBlocks = [];
      this.labelStacks = [];
      this.currentContainedTextElements = [];
      this.tagLevel = 0;
      this.blockTagLevel = null;
      this.ignorableElementDepth = 0;
      this.inBody = 0;
      this.inAnchor = 0;
      this.inAnchorText = false;
      this.clearTextBuffer();
      return this.flush = false;
    };

    BoilerpipeParser.prototype.parseDocumentFromHTML = function(html) {
      this.resetToInitialState();
      this.startParsingDocument();
      this.parser.parseComplete(html);
      this.endParsingDocument();
      return new TextDocument(this.title, this.textBlocks);
    };

    BoilerpipeParser.prototype.startParsingDocument = function() {};

    BoilerpipeParser.prototype.endParsingDocument = function() {
      return this.flushBlock();
    };

    BoilerpipeParser.prototype.startElement = function(elementName, attributes) {
      this.labelStacks.push([]);
      switch (this.elementTypeForTag(elementName)) {
        case BoilerpipeParser.IgnorableElementAction:
          this.ignorableElementDepth++;
          this.tagLevel++;
          break;
        case BoilerpipeParser.BodyElementAction:
          this.flushBlock();
          this.inBody++;
          this.tagLevel++;
          break;
        case BoilerpipeParser.AnchorTextElementAction:
          this.inAnchor++;
          this.tagLevel++;
          if (this.inAnchor > 1) {
            console.log("Warning: SAX input contains nested A elements -- You have probably hit a bug in your HTML parser (e.g., NekoHTML bug #2909310). Please clean the HTML externally and feed it to boilerpipe again. Trying to recover somehow...");
            endElement(elementName);
          }
          if (this.ignorableElementDepth === 0) {
            this.addToken(BoilerpipeParser.AnchorTextStart);
          }
          break;
        case BoilerpipeParser.InlineWhitespaceElementAction:
        case BoilerpipeParser.InlineNoWhitespaceElementAction:
          break;
        default:
          this.tagLevel++;
          this.flush = true;
      }
      return this.lastStartTag = elementName;
    };

    BoilerpipeParser.prototype.foundText = function(text) {
      var strippedContent, tokens;
      this.textElementIdx++;
      if (this.flush) {
        this.flushBlock();
      }
      if (this.inIgnorableElement > 0 || (text == null) || text.length === 0) {
        return;
      }
      strippedContent = text.stripWhitespace();
      if (strippedContent.length === 0) {
        return;
      }
      this.textBuffer += text;
      tokens = this.tokenizeString(text);
      if (tokens) {
        this.tokenBuffer.merge(tokens);
      }
      if (this.blockTagLevel == null) {
        this.blockTagLevel = this.tagLevel;
      }
      return this.currentContainedTextElements.push(this.textElementIdx);
    };

    BoilerpipeParser.prototype.endElement = function(elementName) {
      switch (this.elementTypeForTag(elementName)) {
        case BoilerpipeParser.IgnorableElementAction:
          this.ignorableElementDepth--;
          this.tagLevel--;
          this.flush = true;
          break;
        case BoilerpipeParser.BodyElementAction:
          this.flushBlock();
          this.inBody--;
          this.tagLevel--;
          break;
        case BoilerpipeParser.AnchorTextElementAction:
          this.inAnchor--;
          if (this.inAnchor === 0 && this.ignorableElementDepth === 0) {
            this.addToken(BoilerpipeParser.AnchorTextEnd);
          }
          this.tagLevel--;
          break;
        case BoilerpipeParser.InlineWhitespaceElementAction:
        case BoilerpipeParser.InlineNoWhitespaceElementAction:
          break;
        default:
          this.tagLevel--;
          this.flush = true;
      }
      if (this.flush) {
        this.flushBlock();
      }
      this.lastEndTag = elementName;
      return this.labelStacks.pop();
    };

    BoilerpipeParser.prototype.flushBlock = function() {
      var currentLineLength, currentText, maxLineLength, numTokens, numWords, numWordsCurrentLine, numWordsInAnchorText, numWordsInWrappedLines, numWrappedLines, textBlock, token, _i, _len, _ref, _ref1;
      this.flush = false;
      if ((this.inBody == null) || this.inBody <= 0) {
        if (((_ref = this.lastStartTag) != null ? _ref.normalize() : void 0) === "title") {
          this.title = this.textBuffer.stripWhitespace();
        }
        this.clearTextBuffer();
        return;
      }
      if (!this.tokenBuffer.length > 0) {
        this.clearTextBuffer();
        return;
      }
      numWords = 0;
      numWordsInAnchorText = 0;
      numWrappedLines = 0;
      currentLineLength = -1;
      maxLineLength = 80;
      numTokens = 0;
      numWordsCurrentLine = 0;
      _ref1 = this.tokenBuffer;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        token = _ref1[_i];
        if (token === BoilerpipeParser.AnchorTextStart) {
          this.inAnchorText = true;
        } else if (token === BoilerpipeParser.AnchorTextEnd) {
          this.inAnchorText = false;
        } else if (token.isWord()) {
          numTokens++;
          numWords++;
          numWordsCurrentLine++;
          if (this.inAnchorText) {
            numWordsInAnchorText++;
          }
          currentLineLength += token.length + 1;
          if (currentLineLength > maxLineLength) {
            numWrappedLines++;
            currentLineLength = token.length;
            numWordsCurrentLine = 1;
          }
        } else {
          numTokens++;
        }
      }
      if (numTokens > 0) {
        if (numWrappedLines === 0) {
          numWordsInWrappedLines = numWords;
          numWrappedLines = 1;
        } else {
          numWordsInWrappedLines = numWords - numWordsCurrentLine;
        }
        currentText = this.textBuffer;
        textBlock = new TextBlock(currentText, this.currentContainedTextElements, this.blockTagLevel, numWords, numWordsInAnchorText, numWordsInWrappedLines, numWrappedLines, this.offsetBlocks);
        this.textBlocks.push(textBlock);
        this.offsetBlocks++;
        this.blockTagLevel = null;
        this.currentContainedTextElements = [];
      }
      return this.clearTextBuffer();
    };

    BoilerpipeParser.prototype.addToken = function(token) {
      if (token != null) {
        return this.tokenBuffer.push(token);
      }
    };

    BoilerpipeParser.prototype.addTextBlock = function(textBlock) {};

    BoilerpipeParser.prototype.clearTextBuffer = function() {
      this.textBuffer = '';
      return this.tokenBuffer = [];
    };

    BoilerpipeParser.prototype.elementTypeForTag = function(tagName) {
      this.mapOFActionsToTags = {
        "style": BoilerpipeParser.IgnorableElementAction,
        "script": BoilerpipeParser.IgnorableElementAction,
        "option": BoilerpipeParser.IgnorableElementAction,
        "object": BoilerpipeParser.IgnorableElementAction,
        "embed": BoilerpipeParser.IgnorableElementAction,
        "applet": BoilerpipeParser.IgnorableElementAction,
        "a": BoilerpipeParser.AnchorTextElementAction,
        "body": BoilerpipeParser.BodyElementAction,
        "strike": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "u": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "b": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "i": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "em": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "strong": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "span": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "sup": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "code": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "tt": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "sub": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "var": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "abbr": BoilerpipeParser.InlineWhitespaceElementAction,
        "acronym": BoilerpipeParser.InlineWhitespaceElementAction,
        "font": BoilerpipeParser.InlineNoWhitespaceElementAction,
        "noscript": BoilerpipeParser.IgnorableElementAction
      };
      tagName = tagName.toLowerCase();
      return this.mapOFActionsToTags[tagName];
    };

    BoilerpipeParser.prototype.tokenizeString = function(input) {
      return input.match(/\ue00a?[\w\"'\.,\!\@\-\:\;\$\?\(\)/]+/g);
    };

    return BoilerpipeParser;

  })();

  /*
  	
  	Filters
  	=======
  	
  	Simple Filters:
  	---------------
  		MarkEverythingContentFilter - Marks all blocks as content.
  		InvertedFilter - Reverts the "isContent" flag for all TextBlocks
  		BoilerplateBlockFilter - Removes TextBlocks which have explicitly been marked as "not content". 
  		MinWordsFilter - Keeps only those content blocks which contain at least k words.
  		MinClauseWordsFilter - Keeps only blocks that have at least one segment fragment ("clause") with at least k words
  		SplitParagraphBlocksFilter - Splits TextBlocks at paragraph boundaries
  		SurroundingToContentFilter
  		LabelToBoilerplateFilter - Marks all blocks that contain a given label as "boilerplate".
  		LabelToContentFilter - Marks all blocks that contain a given label as "content".
  	
  	Heuristic Filters:
  	------------------
  		SimpleBlockFusionProcessor - Merges two subsequent blocks if their text densities are equal.
  		ContentFusion
  		LabelFusion - Fuses adjacent blocks if their labels are equal.
  		BlockProximityFusion - Fuses adjacent blocks if their distance (in blocks) does not exceed a certain limit.
  		KeepLargestBlockFilter - Keeps the largest {@link TextBlock} only (by the number of words)
  		ExpandTitleToContentFilter - Marks all TextBlocks "content" which are between the headline and the part that has already been marked content, if they are marked MIGHT_BE_CONTENT
  		ArticleMetadataFilter
  		AddPrecedingLabelsFilter - Adds the labels of the preceding block to the current block, optionally adding a prefix.
  		DocumentTitleMatchClassifier - Marks TextBlocks which contain parts of the HTML TITLE tag
  	
  	English-trained Heuristic Filters:
  	----------------------------------
  		MinFulltextWordsFilter - Keeps only those content blocks which contain at least k full-text words
  		KeepLargestFulltextBlockFilter - Keeps the largest TextBlock only (by the number of words)
  		IgnoreBlocksAfterContentFilter - Marks all blocks as "non-content" that occur after blocks that have been marked INDICATES_END_OF_TEXT
  		IgnoreBlocksAfterContentFromEndFilter - like above
  		TerminatingBlocksFinder - Finds blocks which are potentially indicating the end of an article text and marks them with INDICATES_END_OF_TEXT
  		NumWordsRulesClassifier - Classifies TextBlocks as content/not-content through rules that have been determined using the C4.8 machine learning algorithm
  		DensityRulesClassifier - lassifies TextBlocks as content/not-content through rules that have been determined using the C4.8 machine learning algorithm
  		CanolaFilter - A full-text extractor trained on krdwrd Canola
  */


  BaseFilter = (function() {
    function BaseFilter() {}

    BaseFilter.prototype.process = function(document) {
      return false;
    };

    return BaseFilter;

  })();

  FilterChain = (function(_super) {
    __extends(FilterChain, _super);

    function FilterChain(filters) {
      this.filters = filters;
    }

    FilterChain.prototype.process = function(document) {
      var filter, hasDetectedChanges, _i, _len, _ref;
      hasDetectedChanges = false;
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        filter = _ref[_i];
        hasDetectedChanges |= filter.process(document);
      }
      return hasDetectedChanges;
    };

    return FilterChain;

  })(BaseFilter);

  MarkEverythingContentFilter = (function(_super) {
    __extends(MarkEverythingContentFilter, _super);

    function MarkEverythingContentFilter() {
      _ref = MarkEverythingContentFilter.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    MarkEverythingContentFilter.prototype.process = function(document) {
      var textBlock, _i, _len, _ref1, _results;
      _ref1 = document.textBlocks;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        textBlock = _ref1[_i];
        _results.push(textBlock.isContent = true);
      }
      return _results;
    };

    return MarkEverythingContentFilter;

  })(BaseFilter);

  /*
  Heuristic Filters:
  */


  SimpleBlockFusionProcessor = (function(_super) {
    __extends(SimpleBlockFusionProcessor, _super);

    function SimpleBlockFusionProcessor() {
      _ref1 = SimpleBlockFusionProcessor.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SimpleBlockFusionProcessor.prototype.process = function(document) {
      var count, currentTextBlock, hasDetectedChanges, previousTextBlock, textBlocks, _i, _len, _ref2;
      textBlocks = document.textBlocks;
      if (textBlocks.length < 2) {
        return false;
      }
      hasDetectedChanges = false;
      previousTextBlock = textBlocks[0];
      count = 0;
      _ref2 = textBlocks.slice(1);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        currentTextBlock = _ref2[_i];
        if ((previousTextBlock != null) && previousTextBlock.textDensity === currentTextBlock.textDensity) {
          previousTextBlock.mergeNext(currentTextBlock);
          document.removeTextBlock(currentTextBlock);
          hasDetectedChanges = true;
        } else {
          previousTextBlock = currentTextBlock;
        }
      }
      console.log(document.content());
      return hasDetectedChanges;
    };

    return SimpleBlockFusionProcessor;

  })(BaseFilter);

  BlockProximityFusion = (function(_super) {
    __extends(BlockProximityFusion, _super);

    function BlockProximityFusion(maxBlocksDistance, contentOnly, sameTagLevelOnly) {
      if (maxBlocksDistance == null) {
        maxBlocksDistance = 1;
      }
      if (contentOnly == null) {
        contentOnly = false;
      }
      if (sameTagLevelOnly == null) {
        sameTagLevelOnly = false;
      }
      this.maxBlocksDistance = maxBlocksDistance;
      this.contentOnly = contentOnly;
      this.sameTagLevelOnly = sameTagLevelOnly;
    }

    BlockProximityFusion.prototype.process = function(document) {
      var currentTextBlock, diffBlocks, hasDetectedChanges, index, previousTextBlock, startIndex, textBlock, textBlocks, _i, _j, _len, _len1, _ref2;
      textBlocks = document.textBlocks;
      if (textBlocks.length < 2) {
        return false;
      }
      if (this.contentOnly) {
        startIndex = null;
        for (index = _i = 0, _len = textBlocks.length; _i < _len; index = ++_i) {
          textBlock = textBlocks[index];
          if (textBlock.isContent) {
            startIndex = index;
            break;
          }
        }
        if (startIndex == null) {
          return false;
        }
      } else {
        startIndex = 0;
      }
      previousTextBlock = textBlocks[startIndex];
      hasDetectedChanges = false;
      _ref2 = textBlocks.slice(startIndex + 1);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        currentTextBlock = _ref2[_j];
        if (!currentTextBlock.isContent) {
          previousTextBlock = currentTextBlock;
          continue;
        }
        diffBlocks = currentTextBlock.offsetBlocksStart - previousTextBlock.offsetBlocksEnd - 1;
        if (diffBlocks <= this.maxBlocksDistance) {
          if (!(this.contentOnly && !previousTextBlock.isContent || !currentTextBlock.isContent) && !(this.sameTagLevelOnly && previousTextBlock.tagLevel !== currentTextBlock.tagLevel)) {
            previousTextBlock.mergeNext(currentTextBlock);
            document.removeTextBlock(currentTextBlock);
            hasDetectedChanges = true;
            break;
          }
        }
        previousTextBlock = currentTextBlock;
      }
      return hasDetectedChanges;
    };

    return BlockProximityFusion;

  })(BaseFilter);

  DocumentTitleMatchClassifier = (function(_super) {
    __extends(DocumentTitleMatchClassifier, _super);

    function DocumentTitleMatchClassifier(title, useDocumentTitle) {
      if (useDocumentTitle == null) {
        useDocumentTitle = false;
      }
      this.useDocumentTitle = useDocumentTitle;
      this.potentialTitles = this.findPotentialTitles("title");
    }

    DocumentTitleMatchClassifier.prototype.findPotentialTitles = function(title) {
      var pattern, potentialTitles, _i, _len, _ref2, _results;
      title = title != null ? title.stripWhitespace() : void 0;
      if ((title == null) || title.length === 0) {
        return null;
      }
      potentialTitles = [];
      potentialTitles.push(title);
      _ref2 = [/[ ]*[\||:][ ]*/, /[ ]*[\||:\(\)][ ]*/, /[ ]*[\||:\(\)\-][ ]*/, /[ ]*[\||,|:\(\)\-][ ]*/];
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        pattern = _ref2[_i];
        _results.push(this.longestMatch(title, pattern));
      }
      return _results;
    };

    DocumentTitleMatchClassifier.prototype.process = function(document) {
      var potentialTitle, text, textBlock, _i, _j, _len, _len1, _ref2, _ref3;
      if (this.useDocTitle) {
        self.potentialTitles = this.findPotentialTitles(document.title);
      }
      if ((this.potentialTitles == null) || this.potentialTitles.length === 0) {
        return false;
      }
      _ref2 = document.textBlocks;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        textBlock = _ref2[_i];
        text = textBlock.text.toLowerCase().stripWhitespace();
        _ref3 = this.potentialTitles;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          potentialTitle = _ref3[_j];
          if ((potentialTitle != null ? potentialTitle.toLowerCase() : void 0) === text) {
            textBlock.addLabel(TextBlock.Title);
            return true;
          }
        }
      }
      return false;
    };

    DocumentTitleMatchClassifier.prototype.longestMatch = function(title, pattern) {
      var longestNumWords, longestPart, numWords, section, sections, _i, _len;
      sections = title.split(pattern);
      if (sections.length === 1) {
        return null;
      }
      longestNumWords = 0;
      longestPart = "";
      for (_i = 0, _len = sections.length; _i < _len; _i++) {
        section = sections[_i];
        if (section.contains(".com")) {
          continue;
        }
        numWords = section.numberOfWords();
        if (numWords > longestNumWords || section.len > longestPart.length) {
          longestNumWords = numWords;
          longestPart = section;
        }
      }
      if (longestPart.length > 0) {
        return longestPart.stripWhitespace();
      } else {
        return false;
      }
    };

    return DocumentTitleMatchClassifier;

  })(BaseFilter);

  TerminatingBlocksFinder = (function(_super) {
    __extends(TerminatingBlocksFinder, _super);

    function TerminatingBlocksFinder() {
      _ref2 = TerminatingBlocksFinder.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    TerminatingBlocksFinder.prototype.process = function(document) {
      var equalMatch, foundMatch, hasDetectedChanges, inMatches, lowercaseText, numbersMatch, startMatches, text, textBlock, _i, _len, _ref3, _ref4;
      hasDetectedChanges = false;
      _ref3 = document.textBlocks;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        textBlock = _ref3[_i];
        if (textBlock.numWords >= 15) {
          continue;
        }
        text = (_ref4 = textBlock.text) != null ? _ref4.stripWhitespace() : void 0;
        if (text.length < 8) {
          continue;
        }
        lowercaseText = text.toLowerCase();
        startMatches = [" reuters", "please rate this", "post a comment"];
        inMatches = ["what you think...", "add your comment", "add comment", "reader views", "have your say", "reader comments", "rtta artikeln"];
        equalMatch = ["thanks for your comments - this feedback is now closed"];
        numbersMatch = [" comments", " users responded in"];
        foundMatch = false;
        foundMatch |= __indexOf.call(equalMatch != null, lowercaseText) >= 0;
        foundMatch |= lowercaseText.startsWith("comments");
        foundMatch |= !startMatches.every(function(match) {
          return !lowercaseText.startsWith(match);
        });
        foundMatch |= !inMatches.every(function(match) {
          return !~lowercaseText.indexOf(match);
        });
        foundMatch |= !equalMatch.every(function(match) {
          return lowercaseText !== match;
        });
        foundMatch |= this.startsWithNumber(lowercaseText, numbersMatch);
        if (foundMatch) {
          textBlock.addLabel(TextBlock.EndOfText);
          hasDetectedChanges = true;
        }
      }
      return hasDetectedChanges;
    };

    TerminatingBlocksFinder.prototype.startsWithNumber = function(text, matchStrArr) {
      var matchStr, matchesNumber;
      matchesNumber = text.search(/^\D/);
      if (matchesNumber < 0) {
        matchesNumber = text.length;
      }
      if (matchesNumber === 0) {
        return false;
      }
      return any((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = matchStrArr.length; _i < _len; _i++) {
          matchStr = matchStrArr[_i];
          _results.push(text.startsWith(matchStr, pos));
        }
        return _results;
      })());
      return true;
    };

    return TerminatingBlocksFinder;

  })(BaseFilter);

  NumWordsRulesClassifier = (function(_super) {
    __extends(NumWordsRulesClassifier, _super);

    function NumWordsRulesClassifier() {
      _ref3 = NumWordsRulesClassifier.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    NumWordsRulesClassifier.prototype.process = function(document) {
      var currentTextBlock, hasDetectedChanges, index, nextTextBlock, numberOfTextBlocks, previousTextBlock, textBlocks, _i, _len;
      textBlocks = document.textBlocks;
      hasDetectedChanges = false;
      numberOfTextBlocks = textBlocks.length;
      for (index = _i = 0, _len = textBlocks.length; _i < _len; index = ++_i) {
        currentTextBlock = textBlocks[index];
        previousTextBlock = index > 0 ? textBlocks[index - 1] : new TextBlock();
        nextTextBlock = index + 1 < numberOfTextBlocks ? textBlocks[index + 1] : new TextBlock();
        hasDetectedChanges |= this.classify(previousTextBlock, currentTextBlock, nextTextBlock);
      }
      return hasDetectedChanges;
    };

    NumWordsRulesClassifier.prototype.classify = function(previousTextBlock, currentTextBlock, nextTextBlock) {
      var isContent;
      isContent = true;
      if (currentTextBlock.linkDensity > 0.333333) {
        isContent = false;
      } else if (previousTextBlock.linkDensity > 0.555556) {
        if (currentTextBlock.numWords <= 16 && nextTextBlock.numWords <= 15 && previousTextBlock.numWords <= 4) {
          isContent = false;
        }
      } else if (currentTextBlock.numWords <= 40 && nextTextBlock.numWords <= 17) {
        isContent = false;
      }
      return currentTextBlock.isContent = isContent;
    };

    return NumWordsRulesClassifier;

  })(BaseFilter);

  Boilerpipe = (function() {
    function Boilerpipe() {}

    Boilerpipe.ArticleExtractor = "ArticleExtractor";

    Boilerpipe.DefaultExtractor = "DefaultExtractor";

    Boilerpipe.KeepEverythingExtractor = "KeepEverythingExtractor";

    Boilerpipe.prototype.contentFromHTML = function(html, filterType) {
      var content, document;
      document = this.documentFromHTML(html);
      console.log("number of text blocks: " + document.textBlocks.length);
      content = this.filterTextBlocks(document, filterType);
      console.log("content: " + content.length);
      return content;
    };

    Boilerpipe.prototype.documentFromHTML = function(html, filterType) {
      var parser;
      parser = new BoilerpipeParser;
      return parser.parseDocumentFromHTML(html);
    };

    Boilerpipe.prototype.filterTextBlocks = function(document, filterType) {
      var filterChain, hasChanges;
      filterChain = this.filterChainForType(filterType);
      hasChanges = filterChain != null ? filterChain.process(document) : void 0;
      return document.content();
    };

    Boilerpipe.prototype.filterChainForType = function(filterType) {
      switch (filterType) {
        case Boilerpipe.ArticleExtractor:
          /*
          				A full-text extractor which is tuned towards news articles.
          				In this scenario it achieves higher accuracy than DefaultExtractor.
          				Works very well for most types of Article-like HTML.
          */

          return new FilterChain([new TerminatingBlocksFinder(), new DocumentTitleMatchClassifier(null, false), new NumWordsRulesClassifier()]);
        case Boilerpipe.KeepEverythingExtractor:
          return new FilterChain([new MarkEverythingContentFilter()]);
        default:
          /*
          				Boilerpipe.DefaultExtractor
          				Usually worse than ArticleExtractor, but simpler/no heuristics
          				A quite generic full-text extractor
          */

          return new FilterChain([new SimpleBlockFusionProcessor(), new BlockProximityFusion(1, false, false), new DensityRulesClassifier()]);
      }
    };

    return Boilerpipe;

  })();

  fs = require('fs');

  getContentFromHTML = function(html) {
    var boilerpipe;
    boilerpipe = new Boilerpipe;
    return boilerpipe.contentFromHTML(html, Boilerpipe.ArticleExtractor);
  };

  getContentFromFile = function(filePath) {
    return fs.readFile(filePath, function(err, data) {
      var result;
      return result = getContentFromHTML(data);
    });
  };

  getContentFromFile('index.html');

}).call(this);
